<<< Inheritance : 상속 , 케이쇼우(계승) >>>
1. 정의 : 기존 클래스의 프로파티,메소드 등 멤버들을 그대로 상속 받아
          새로운 클래스를 정의 하는 것 , 다중상속 불가

슈퍼클래스(スーパー) : 서브클래스(サブ) = 부모 : 자식 = 상위 : 하위 = 기본 : 파생

class サブ클래스명 extends スーパー클래스명{
  // サブ클래스의 독자적인 멤버들을 정의
}
* サブ클래스의 인스턴스화 : スーパー클래스의 멤버 , サブ클래스의 멤버가 결합되어 생성 *

2. 오버라이딩(オーバーライド)
1) 메소드 オーバーライド : サブ클래스에서 スーパー클래스의 메소드를 재정의

조건
  1> スーパー클래스의 메소드명과 같아야 함
  2> スーパー클래스의 파라메터 구성(순서,개수)이 같아야 한다. //php 타입 없음
  3> 엑세스(アクセス)수식자의 허용 레벨을 같거나 더 확대되게(넓게) 정의 해야함.
  protected -> protected , public
  private(불가)

* サブ클래스에서 スーパー클래스의 메소드를 호출
   ㄴ parent::메소드명(인수리스트); *

* php에서 サブ클래스를 인스턴스화할 때 특별히 지정하지 않으면
  スーパー클래스의 생성자가 호출되지 않는다.
  특별히 지정하여 호출하는 방법은
    ㄴ parent::__construct(인수리스트); *

* 메소드를 정의할 때 オーバーライド 못하게 하고싶을때
  public final function 메소드명(파라메터 리스트){} *

* 계승(상속)금지?
  ㄴ final class 클래스명{} *

<<< 다형성(ポリモーフィズム , polymorphism) >>> / to String
3. 동일한 이름의 메소드가 * 상황(해당 객체)에 따라 * 다른 처리가 되도록 하는 것
   장점 : 같은 목적의 기능에 대해 다른 메소드명을 기억할 필요가 없게 됨

* encapsulation(캡슐화) , inheritance(상속) , polymorphism(다형성) *

4. 추상클래스(abstract class)
ポリモーフィズム를 위해서 상속+오버라이드 로 구현이 가능하지만 불충분하다.
- why : サブ클래스에서 반드시 オーバーライド 한다는 보장이 없다.
        => 추상메소드를 사용하는 이유

추상메소드 abstract 수식자를 가진 메소드로 정의만 있고 몸체(구현부분)이 없는 메소드
          계승하는 サブ클래스에서 반드시 구현(실장,実装)해야 함.
abstract アクセス수식자 function 메소드명(파라미터 리스트);
추상클래스 : 추상메소드를 가지고 있는 클래스
abstract class 클래스명{
  abstract アクセス수식자 function 메소드명(파라미터 리스트);
}
アクセス수식자 : public , protected

5. 인터페이스(インターフェース , interface) : 추상메소드만 가진 특수한 클래스
메소드의 내용은 몰라도 사용법만 알려주면 된다.
abstract 안붙임
사용가능 アクセス수식자 : public(생략 가능) 사용해라고 주는건데 숨기는건 무의미(공개용)
1) 정의
interface 인터페이스명{
  const 상수명 = 값; // 정수(定数)

  [abstract] [public] function 메소드명(인수리스트);
    * 대괄호 안의 내용은 써도 되고 안써도 되고 *
    몸체없이 정의만 해야됨
}
2) 실장 : 구현 implement
class 클래스명 implements 인터페이스명1,...,인터페이스명n{
  인터페이스 여러개 구현 가능
  // インターフェース의 추상메소드들 구현
}

* インターフェース를 구현한 클래스에서 インターフェース의 상수 참조 *
  インターフェース명::상수명 , self::상수명

* (다형성 걸려있을경우) インターフェース의 정보를 알아내는 함수 *
// http://php.net/manual/kr/function.get-class.php
get_class()
get_class_methods()
get_object_vars()
get_parent_class()
instanceof 연산자


























>
